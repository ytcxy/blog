<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/04/30/200430%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/04/30/200430%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="广域网（WAN）"><a href="#广域网（WAN）" class="headerlink" title="广域网（WAN）"></a>广域网（WAN）</h3><p><code>任务是通过长距离运送主机发送的数据</code></p><h3 id="城域网（MAN）"><a href="#城域网（MAN）" class="headerlink" title="城域网（MAN）"></a>城域网（MAN）</h3><p><code>将多个局域网进行互联</code></p><h3 id="局域网（LAN）"><a href="#局域网（LAN）" class="headerlink" title="局域网（LAN）"></a>局域网（LAN）</h3><p><code>学校或企业大多数拥有多个互联的局域网</code></p><h3 id="个人区域网（PAN）"><a href="#个人区域网（PAN）" class="headerlink" title="个人区域网（PAN）"></a>个人区域网（PAN）</h3><p><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络</code></p><a id="more"></a><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>链路</strong></p><p><code>一个节点到相邻节点的一段物理链路</code></p><p><strong>数据链路</strong></p><p><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路</code></p><p><strong>循环冗余检验CRC</strong></p><p><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术</code></p><p><strong>帧</strong>  </p><p><code>一个数据链路层的传输单元， 由一个数据链路层首部和其他携带的封包所组成协议的单元</code></p><ul><li><p>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p></li><li><p>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p></li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><strong>TCP</strong></p><p> 传输控制协议</p><p><strong>UDP</strong></p><p>用户数据报协议</p><ul><li><p>UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p></li><li><p>TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p></li><li><p>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序从源代码到可执行程序的过程</title>
      <link href="/2020/04/28/200428%E7%A8%8B%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/04/28/200428%E7%A8%8B%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一个源程序到一个可执行程序的过程：预编译、编译、汇编、链接。</p><p>编译是主要部分： 其中又分为六个部分</p><ul><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>中间代码生成</li><li>目标代码生成</li><li>优化</li></ul><p>链接分为静态链接和动态链接</p><a id="more"></a><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p><strong>主要处理源代码文件中的以“#”开头的预编译指令。</strong></p><p>1.删除所有的#define，展开所有的宏定义。<br>2.处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。<br>3.处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。<br>4.删除所有的注释，“//”和“/**/”。<br>5.保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。<br>6.添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p><p>C语言的宏替换和文件包含的工作，不归入编译器的范围，而是交给独立的预处理器。<br>C语言中源代码文件的文件扩展名为.c，头文件的文件扩展名为.h，经预编译之后，生成xxx.i文件。<br>在C++，源代码文件的扩展名是.cpp或.cxx，头文件的文件扩展名为.hpp，经预编译之后，生成xxx.ii文件。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><strong>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</strong></p><p>C语言的代码，经编译后产生的文件名为xxx.s。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p><strong>将汇编代码转变成机器可以执行的指令(机器码文件)。</strong></p><p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>之后就形成了可执行文件。 </p><p>（1）静态链接　在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。(个人备注：静态链接将链接库的代码复制到可执行程序中，使得可执行程序体积变大)</p><p>（2）动态链接　　在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。（个人备注：动态链接指的是需要链接的代码放到一个共享对象中，共享对象映射到进程虚地址空间，链接程序记录可执行程序将来需要用的代码信息，根据这些信息迅速定位相应的代码片段。）</p><p>　　对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。</p>]]></content>
      
      
      <categories>
          
          <category> 日常总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell学习</title>
      <link href="/2020/04/26/200426shell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/04/26/200426shell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Shell学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常总结 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200426Linux学习</title>
      <link href="/2020/04/26/200426Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/04/26/200426Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><p><code>cd usr</code> :  切换到该目录下的 usr 目录</p></li><li><p><code>cd ..(cd ../)</code>:  切换到上一层目录</p></li><li><p><code>cd /</code> : 切换到系统的根目录</p></li><li><p><code>cd ~</code> : 切换到用户的主目录</p></li><li><p><code>cd -</code> : 切换到上一个操作所在目录</p></li></ul><h3 id="目录的操作命令"><a href="#目录的操作命令" class="headerlink" title="目录的操作命令"></a>目录的操作命令</h3><ol><li><p><code>mkdir name</code> ：增加目录</p></li><li><p><code>ls</code>:　查看目录信息</p></li><li><p><code>find name args</code>: 寻找目录，　name 是目录，　args 参数</p><p>实例：</p><ul><li><p>列出当前目录以及子目录下的所有文件和文件夹: <code>find .</code></p></li><li><p>在 <code>/home</code>目录下查找以<code>.txt</code>结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></p></li><li><p>同上，但是忽略大小写：<code>find /home -iname &quot;*.txt&quot;</code></p></li><li><p>当前目录及其子目录下查找所有以 .txt, .pdf 结尾的文件: </p><p><code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></p></li></ul></li><li><p><code>mv 目录名称 新目录名称</code>:  修改目录的名称(改) </p></li><li><p><code>mv 目录名称 目录的新位置</code> 移动目录的位置, 剪切</p></li><li><p><code>cp -r 目录名称 目录拷贝的目标位置</code> </p><p>cp 命令不仅可以拷贝目录和可以拷贝文件,压缩包等,拷贝文件和压缩包时不用写 -r 递归. </p></li><li><p><code>rm [-rf] 目录</code>:删除目录</p><p>直接加上　-rf 就是不用逐一确认了. </p></li></ol><h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ol><li><code>touch 文件名称</code>:　文件的创建（增）</li><li><code>cat/more/less/tail  文件名称</code>　　文件的查看<ul><li><code>cat</code> 查看显示文件内容</li><li><code>more</code>: 可以显示百分比，回车可以向下一行，空格可以向下一页，ｑ可以退出查看</li><li><code>less</code>：可以使用键盘上的　PgUp, PgDn 向上向下翻页, q 结束查看.</li><li><code>tail -10</code> 查看文件的后10行, Ctrl +Ｃ　结束．</li></ul></li></ol><h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><ul><li><p>打包并压缩文件</p><p>Linux 中的打包文件是以.tar结尾的,压缩的命令一般是以.gz结尾的.</p><p>一般打包和压缩是同时进行的.所以 最后的后缀名就是 .tar.gz</p><p><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></p><p>z：调用gzip压缩命令进行压缩</p><p>c：打包文件</p><p>v：显示运行过程</p><p>f：指定文件名</p><p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：</p><p><strong>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</strong></p><p><strong>或：tar -zcvf test.tar.gz       /test/</strong></p></li><li><p>解压压缩包</p><p>命令:　<code>tar [-xvf] 压缩文件</code></p><p>其中：x：代表解压</p><p>示例：</p><p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong>tar -xvf test.tar.gz</strong></p><p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong>tar -xvf test.tar.gz -C /usr</strong>（- C代表指定解压的位置）</p></li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><code>pwd</code> :　显示当前所在位置</li><li><code>shutdown</code> 关机</li><li><code>reboot</code> 重开机</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常总结 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collections 工具类和 Arrays 工具类</title>
      <link href="/2020/04/25/200425Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C-Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2020/04/25/200425Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C-Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Collections-工具类和-Arrays-工具类常见方法"><a href="#Collections-工具类和-Arrays-工具类常见方法" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法"></a>Collections 工具类和 Arrays 工具类常见方法</h1><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void reverse(List list)&#x2F;&#x2F;反转</span><br><span class="line">void shuffle(List list)&#x2F;&#x2F;随机排序</span><br><span class="line">void sort(List list)&#x2F;&#x2F;按自然排序的升序排序</span><br><span class="line">void sort(List list, Comparator c)&#x2F;&#x2F;定制排序，由Comparator控制排序逻辑</span><br><span class="line">void swap(List list, int i , int j)&#x2F;&#x2F;交换两个索引位置的元素</span><br><span class="line">void rotate(List list, int distance)&#x2F;&#x2F;旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Collections.rotate(arrayList, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.rotate(arrayList, 4):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void shuffle(List list),随机排序</span></span><br><span class="line">Collections.shuffle(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.shuffle(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void swap(List list, int i , int j),交换两个索引位置的元素</span></span><br><span class="line">Collections.swap(arrayList, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.swap(arrayList, 2, 5):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><h3 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(List list, Object key)&#x2F;&#x2F;对List进行二分查找，返回索引，注意List必须是有序的</span><br><span class="line">int max(Collection coll)&#x2F;&#x2F;根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span><br><span class="line">int max(Collection coll, Comparator c)&#x2F;&#x2F;根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span><br><span class="line">void fill(List list, Object obj)&#x2F;&#x2F;用指定的元素代替指定list中的所有元素。</span><br><span class="line">int frequency(Collection c, Object o)&#x2F;&#x2F;统计元素出现次数</span><br><span class="line">int indexOfSubList(List list, List target)&#x2F;&#x2F;统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span><br><span class="line">boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList2.add(-<span class="number">3</span>);</span><br><span class="line">arrayList2.add(-<span class="number">5</span>);</span><br><span class="line">arrayList2.add(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.max(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.max(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.min(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.min(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.replaceAll(arrayList, 3, -3):"</span>);</span><br><span class="line">Collections.replaceAll(arrayList, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.frequency(arrayList, -3):"</span>);</span><br><span class="line">System.out.println(Collections.frequency(arrayList, -<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.indexOfSubList(arrayList, arrayList2):"</span>);</span><br><span class="line">System.out.println(Collections.indexOfSubList(arrayList, arrayList2));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.binarySearch(arrayList, 7):"</span>);</span><br><span class="line"><span class="comment">// 对List进行二分查找，返回索引，List必须是有序的</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(Collections.binarySearch(arrayList, <span class="number">7</span>));</span><br></pre></td></tr></table></figure><h3 id="Arrays-类的常见操作："><a href="#Arrays-类的常见操作：" class="headerlink" title="Arrays 类的常见操作："></a>Arrays 类的常见操作：</h3><ol><li>排序： <code>sort()</code></li><li>查找： <code>binarySearch()</code></li><li>比较： <code>equals()</code></li><li>填充： <code>fill()</code></li><li>转列表： <code>asList()</code></li><li>转字符串： <code>toString()</code></li><li>复制： <code>copyOf()</code></li></ol><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************排序 sort****************</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">System.out.print(d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h3 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************查找 binarySearch()****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h3 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************比较 equals****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h3 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************填充fill(批量初始化)****************</span></span><br><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************转列表 asList()****************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment"> * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment"> * 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment"> * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h3 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; *************转字符串 toString()****************</span><br><span class="line">&#x2F;*</span><br><span class="line">* 返回指定数组的内容的字符串表示形式。</span><br><span class="line">*&#x2F;</span><br><span class="line">char[] k &#x3D; &#123; &#39;a&#39;, &#39;f&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;A&#39;, &#39;C&#39;, &#39;B&#39; &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));&#x2F;&#x2F; [a, f, b, c, e, A, C, B]</span><br></pre></td></tr></table></figure><h3 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; *************复制 copy****************</span><br><span class="line">&#x2F;&#x2F; copyOf 方法实现数组复制,h为数组，6为复制的长度</span><br><span class="line">int[] h &#x3D; &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6, &#125;;</span><br><span class="line">int i[] &#x3D; Arrays.copyOf(h, 6);</span><br><span class="line">System.out.println(&quot;Arrays.copyOf(h, 6);：&quot;);</span><br><span class="line">&#x2F;&#x2F; 输出结果：123333</span><br><span class="line">for (int j : i) &#123;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 换行</span><br><span class="line">System.out.println();</span><br><span class="line">&#x2F;&#x2F; copyOfRange将指定数组的指定范围复制到新数组中</span><br><span class="line">int j[] &#x3D; Arrays.copyOfRange(h, 6, 11);</span><br><span class="line">System.out.println(&quot;Arrays.copyOfRange(h, 6, 11)：&quot;);</span><br><span class="line">&#x2F;&#x2F; 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span><br><span class="line">for (int j2 : j) &#123;</span><br><span class="line">System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 换行</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识</title>
      <link href="/2020/04/24/200424java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/04/24/200424java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别"></a>Java 和 C++ 的区别</h2><ul><li>都是面向对象的语言，都支持封装，继承，多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类都是单继承的， C++支持多继承； Java的类不可以多继承，但是接口时可以多继承的。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承父类的相同方法，输入数据一样，但是要做出有别于父亲的响应时，就就要覆盖父类的方法。</p><a id="more"></a><h2 id="Java-面向对象编程的三大特性：-封装，继承，多态"><a href="#Java-面向对象编程的三大特性：-封装，继承，多态" class="headerlink" title="Java 面向对象编程的三大特性： 封装，继承，多态"></a>Java 面向对象编程的三大特性： 封装，继承，多态</h2><h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><h5 id="继承的三点注意："><a href="#继承的三点注意：" class="headerlink" title="继承的三点注意："></a>继承的三点注意：</h5><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong></li><li>子类可以拥有自己属性和方法， 即子类可以对父类进行扩展</li><li>子类可以用自己的方式实现父类的方法</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h2 id="String-StringBuffer-StringBuilder-的区别时什么？-String为什么是不可变的？"><a href="#String-StringBuffer-StringBuilder-的区别时什么？-String为什么是不可变的？" class="headerlink" title="String, StringBuffer, StringBuilder 的区别时什么？ String为什么是不可变的？"></a>String, StringBuffer, StringBuilder 的区别时什么？ String为什么是不可变的？</h2><h5 id="可变性："><a href="#可变性：" class="headerlink" title="可变性："></a>可变性：</h5><p>String 类中使用 final 关键字修饰字符数组来保存字符串， <code>private final char value[]</code></p><p>所以 String 对象是不可变的。</p><p>补充：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p><h2 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li><li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><h2 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h2><ul><li>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>如果成员变量是使用<code>static</code>  修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，那么这个成员变量是属于实例的。 对象是存在于堆内存中的，局部变量是存在于栈内存的。</li><li>成员变量是对象的一部分，它随着对象的创建而存在，局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有赋初值， 则会自动的赋初值，（一种除外， 被 <code>final</code> 修饰的成员变量只能手动赋值）， 局部变量则不会自动赋值。 </li></ul><h2 id="构造方法有哪些特征："><a href="#构造方法有哪些特征：" class="headerlink" title="构造方法有哪些特征："></a>构造方法有哪些特征：</h2><ul><li>名字和类名相同</li><li>没有返回值，但是不能用 void 声明</li><li>生成类的对象时自动执行， 无需调用。</li></ul><h2 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h2><p>==： 判断两个对象的地址是不是相等的</p><p>equals：</p><ul><li>类没有覆盖 equals() 的方法， 等价于 == 的比较方式</li><li>类覆盖了 equal() 的方法， 比较两个内容是不是一样的。 </li></ul><h2 id="hashCode-与-equals-的相关规定"><a href="#hashCode-与-equals-的相关规定" class="headerlink" title="hashCode() 与 equals() 的相关规定"></a>hashCode() 与 equals() 的相关规定</h2><ol><li>如果两个对象相等， 则 hashcode 一定是相等的</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，他们不一定相等。</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li></li></ol><h2 id="简述线程，程序，进程的基本概念。以及他们之间的关系"><a href="#简述线程，程序，进程的基本概念。以及他们之间的关系" class="headerlink" title="简述线程，程序，进程的基本概念。以及他们之间的关系"></a>简述线程，程序，进程的基本概念。以及他们之间的关系</h2><p><strong>线程</strong> 与 进程相似， 但线程是更小的执行单位，一个进程在其执行的过程中可以产生多个线程。</p><p>与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小的多。线程又被称为轻量级进程</p><p><strong>程序</strong> 是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong> 是程序的一次过程， 是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>简单来说，一个进程就是一个执行中的程序。</p><p>线程与进程最大的不同就在于各进程是独立的，而各个线程则不一定。因为同一进程中的线程极有可能会相互影响。</p><p>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h2 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态"></a>线程有哪些基本状态</h2><ul><li>新建状态</li><li>就绪状态</li><li>运行状态</li><li>阻塞状态</li><li>死亡状态</li></ul><h2 id="关于-final-关键字的总结"><a href="#关于-final-关键字的总结" class="headerlink" title="关于 final 关键字的总结"></a>关于 final 关键字的总结</h2><p>final 关键字主要用在三个地方： 变量、方法、类</p><ul><li>对于一个 final 变量， 如果是基本数据类型的变量， 则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始话之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时， 表明这个类不能被继承。 final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个， 第一个原因是把方法锁定，以防任何继承类修改他的含义； 第二个原因是效率。</li></ul><h2 id="获取用键盘输入常用的两种用法"><a href="#获取用键盘输入常用的两种用法" class="headerlink" title="获取用键盘输入常用的两种用法"></a>获取用键盘输入常用的两种用法</h2><p>方法1： 通用 Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>方法二： 通过 BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System,in));</span><br><span class="line">s = input.readLine();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2020/04/23/200423%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/04/23/200423%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="Object：-所有类的超类"><a href="#Object：-所有类的超类" class="headerlink" title="Object： 所有类的超类"></a>Object： 所有类的超类</h3><p>可以使用Object类型的变量引用任何类型的对象：</p><p><code>Object obj = new Employee(&quot;Harry Hacker&quot;, 35000);</code></p><p>在Java中，只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象。</p><h3 id="泛型数组列表："><a href="#泛型数组列表：" class="headerlink" title="泛型数组列表："></a>泛型数组列表：</h3><p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;()</code></p><p>用  add 方法向数组中添加东西。 </p><p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法：</p><p><code>staff.ensuerCapaccity(100)</code></p><p>这个方法调用将分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分配空间。</p><p>另外，还可以把初始容量传递给ArrayList构造器：</p><p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100)</code></p><a id="more"></a><p><code>staff.size()</code> 表示包含实际元素的数目。 </p><p>Java 和 c++ 不一样， 所以不可以用 中括号的形式访问元素， </p><p>要使用get和set方法实现访问或改变数组元素的操作</p><ul><li><p>要设置第 i 个元素： </p><p><code>staff.set(i, harry)</code></p><p>等价于 a[i] = harry， 就是数组赋值， </p></li><li><p>要访问第 i 个元素， </p><p><code>Employee e = staff.get(i)</code></p></li><li><p>要添加一个元素</p><p><code>staff.add(x)</code></p></li><li><p>要删除第 i 个元素</p><p><code>staff.remove(i)</code></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态域与静态方法</title>
      <link href="/2020/04/21/200421%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/21/200421%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="final-修饰："><a href="#final-修饰：" class="headerlink" title="final 修饰："></a>final 修饰：</h3><p>只能够赋值一次， 不能修改， </p><h3 id="static-修饰符："><a href="#static-修饰符：" class="headerlink" title="static 修饰符："></a>static 修饰符：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有 1000个Employee对象， 那么就有 1000 个id， 但是 nextId 只有一个。 </p><h3 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h3><p>在下面两种情况下使用静态方法：</p><p>·一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）。</p><p>·一个方法只需要访问类的静态域（例如：Employee.getNextId）。</p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数值</title>
      <link href="/2020/04/21/200421%E5%A4%A7%E6%95%B0%E5%80%BC/"/>
      <url>/2020/04/21/200421%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>两个有用的类： </p><ul><li>BigInteger      整数运算</li><li>BigDecimal    浮点运算</li></ul><p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a &#x3D; BigInteger.valueOf(100);</span><br></pre></td></tr></table></figure><a id="more"></a><p>不能使用人们熟悉的算术运算符（如：+和*）处理大数值。而需要使用大数值类中的add和multiply方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger c &#x3D; a.add(b); &#x2F;&#x2F; c &#x3D; a + b</span><br><span class="line">BigInteger d &#x3D; c.multiply(b.add(BigInteger.valueOf(2))); &#x2F;&#x2F; d &#x3D; c * (b + 2)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lotteryOdds = lotteryOdds.multiply(BigInteger.valueOf(n-i+ <span class="number">1</span>)).divide(BigInteger.valueOf(i));</span><br></pre></td></tr></table></figure><ul><li>BigInteger add（BigInteger other）</li><li>BigInteger subtract（BigInteger other）</li><li>BigInteger multiply（BigInteger other）</li><li>BigInteger divide（BigInteger other）</li><li>BigInteger mod（BigInteger other）</li></ul><p>上面就是 加减乘除模</p><ul><li>int compareTo（BigInteger other）</li></ul><p>如果这个大整数与另一个大整数other相等，返回0；如果这个大整数小于另一个大整数other，返回负数；否则，返回正数。</p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出</title>
      <link href="/2020/04/21/200421%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2020/04/21/200421%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>首先需要构造一个Scanner对象，并与“标准输入流”System.in关联。</p><p><code>Scanner in = new Scanner(System.in)</code></p><p>nextLine方法将输入一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = in.nextLine();  <span class="comment">//读入一行</span></span><br><span class="line">String t = in.next(); <span class="comment">//读入 String， 遇到空格分隔</span></span><br><span class="line"><span class="keyword">int</span> x = in.nextInt();  <span class="comment">// 读入int</span></span><br><span class="line"><span class="keyword">double</span> d = in.nextDouble(); <span class="comment">// 读入 double</span></span><br></pre></td></tr></table></figure><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><a id="more"></a><p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.format(<span class="string">"Hello, %s, Next"</span>, <span class="string">"sdfg"</span>);</span><br></pre></td></tr></table></figure><p>printf 可以格式化输出： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"Hello, %s Next"</span>, <span class="string">"sdfg"</span>);</span><br></pre></td></tr></table></figure><h3 id="文件输入与输出："><a href="#文件输入与输出：" class="headerlink" title="文件输入与输出："></a>文件输入与输出：</h3><p>要想对文件进行读取，就需要一个用File对象构造一个Scanner对象，如下所示：</p><p>待补： </p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2020/04/21/200421%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/04/21/200421%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>String类的substring方法可以从一个较大的字符串提取出一个子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">String t = s.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>取出来的就是 <code>Hel</code> ， 所以括号里的值， 就是取的区间。 </p><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>Java 语言用 <code>+</code> 号拼接</p><a id="more"></a><p>如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法：</p><p><code>String t = String.join(&quot;,&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;);</code></p><p>结果就是： S,M,L,XL</p><h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p>String 类没有提供用于修改字符串的方法。</p><p>所以只能先提取处理，然后再拼接。</p><p>就是不能直接 <code>s[0] = &quot;b&quot;</code> 这样直接修改。 </p><p>但是可以直接重新赋值。 </p><h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p><code>s.equals(t)</code> 检查 s 和 t 是不是一样的。 </p><p>把变量替换成 真正的字符串也是一样的。 </p><p><code>equalsIgnoreCase()</code> 不区分大小写。 </p><p>一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。</p><h4 id="空串与-Null-串"><a href="#空串与-Null-串" class="headerlink" title="空串与 Null 串"></a>空串与 Null 串</h4><p>空串是 “” 是长度为 0 的串。 </p><p>空串是一个 Java对象， 有自己的长度（0）， 和内容 （空）。 </p><p>String 变量还可以存放一个长特殊的值， <code>null</code> 这表示目前没有任何对象与该变量关联</p><p>要检查一个字符串是否为null，要使用以下条件：</p><p><code>if (s == null)</code></p><p>时要检查一个字符串既不是null也不为空串，这种情况下就需要使用以下条件：</p><p><code>if (s != null &amp;&amp; s.length() !=0 )</code></p><h4 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h4><p>有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串，都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuilder类就可以避免这个问题的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      builder.append(<span class="string">"st"</span>);</span><br><span class="line">      String s = builder.toString();</span><br><span class="line"></span><br><span class="line">      builder.append(<span class="string">"er"</span>);</span><br><span class="line">      String t = builder.toString();</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line">      System.out.println(t);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言元素</title>
      <link href="/2020/04/12/200412%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/"/>
      <url>/2020/04/12/200412%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>可以使用Python中内置的函数对变量类型进行转换。</p><ul><li><code>int()</code> : 转换成整数</li><li><code>float</code> : 转换成浮点数</li><li><code>str()</code> : 转换成字符串</li><li><code>chr()</code> : 一个数字字符， 转换成字符。</li><li><code>ord()</code> 一个字符，转换整数。 </li></ul><a id="more"></a><p>运算符号： </p><ul><li>/  除法</li><li>// 整除</li><li>% 模</li><li>** 乘方</li></ul><h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>[]</code> <code>[:]</code></td><td style="text-align:left">下标，切片</td></tr><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">指数</td></tr><tr><td style="text-align:left"><code>~</code> <code>+</code> <code>-</code></td><td style="text-align:left">按位取反, 正负号</td></tr><tr><td style="text-align:left"><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td style="text-align:left">乘，除，模，整除</td></tr><tr><td style="text-align:left"><code>+</code> <code>-</code></td><td style="text-align:left">加，减</td></tr><tr><td style="text-align:left"><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td style="text-align:left">右移，左移</td></tr><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">按位与</td></tr><tr><td style="text-align:left"><code>^</code> `</td><td style="text-align:left">`</td><td>按位异或，按位或</td></tr><tr><td style="text-align:left"><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td style="text-align:left">小于等于，小于，大于，大于等于</td></tr><tr><td style="text-align:left"><code>==</code> <code>!=</code></td><td style="text-align:left">等于，不等于</td></tr><tr><td style="text-align:left"><code>is</code>  <code>is not</code></td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left"><code>in</code> <code>not in</code></td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left"><code>not</code> <code>or</code> <code>and</code></td><td style="text-align:left">逻辑运算符</td></tr></tbody></table></div><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">a += b</span><br><span class="line">a *= a + <span class="number">2</span>  <span class="comment"># 相当于： a = a * (a + 2)</span></span><br></pre></td></tr></table></figure><p><code>print(&quot;%.1f&quot; % (c)) #: 保留一位小数输出</code></p>]]></content>
      
      
      <categories>
          
          <category> python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 日常学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检索模型与搜索排序</title>
      <link href="/2020/04/08/200408%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
      <url>/2020/04/08/200408%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h4 id="词频因子：-tf"><a href="#词频因子：-tf" class="headerlink" title="词频因子： tf"></a>词频因子： <code>tf</code></h4><p>即一个单词在文档中出现的次数；反复出现的单词，往往能表征文档的主题信息。 </p><p>一种词频因子的变体计算公式是： </p><script type="math/tex; mode=display">W_{tf} = 1 + log(tf)</script><p>公式中的 1 是为了起到平滑的作用。 </p><p>另一种单词词频因子的标题计算公式是： </p><a id="more"></a><p>$W_{tf} = a + (1 - a) * \frac{tf}{max(tf)}$</p><p>其中 a 是调节因子， 新的研究表明 a 的取值为0.4效果更好。 </p><p><code>tf</code> 代表这个单词的实际词频数目，  而 <code>max(tf)</code> 代表文档中所有的单词中出现次数最多的那个单词对应的词频数目。 </p><h4 id="逆文档频率因子：-idf"><a href="#逆文档频率因子：-idf" class="headerlink" title="逆文档频率因子： idf"></a>逆文档频率因子： <code>idf</code></h4><p>给定一个文档集合，那么每个单词的 <code>idf</code> 就确定了。 </p><p>计算公式如下： </p><p>$idf_k = log(\frac{N}{n_k})$</p><p>$N$ 代表文档集合中一共又多少个文档。 </p><p>$n_k$ 代表特征单词在多少个文档中出现过。 </p><p><code>idf</code> 的值越高， 则其区分不同文档的能力就越强。 反之，能力就越弱。 </p><h4 id="tf-idf-框架"><a href="#tf-idf-框架" class="headerlink" title="tf * idf 框架"></a><code>tf * idf</code> 框架</h4><script type="math/tex; mode=display">Weight_{word} = tf * idf</script><p>对于文档D 来说， </p><p>如果 D 中的某个单词的词频很高，而且这个单词在文档集合的其他文档中很少出现，那么这个单词的权值就会很高。 </p><p>如果 D 中的某个单词的词频很高，而且这个单词在文档集合的其他文档中也经常出现，那么这个单词的权值就一般。 </p><h3 id="检索质量评价标准"><a href="#检索质量评价标准" class="headerlink" title="检索质量评价标准"></a>检索质量评价标准</h3><h4 id="精确率与召回率"><a href="#精确率与召回率" class="headerlink" title="精确率与召回率"></a>精确率与召回率</h4><p><img src="https://s1.ax1x.com/2020/04/09/GhXvHU.png" alt="相关图片"></p><p>N ： 代表查询相关且搜索到</p><p>M： 代表查询不相关且搜索到</p><p>K ： 代表查询相关但没搜索到</p><p>L ： 代表查询不相关但没有搜索到； </p><script type="math/tex; mode=display">精确率 = \frac{N}{N+M}</script><script type="math/tex; mode=display">召回率 = \frac{N}{N + K}</script><h3 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h3><p><code>MAP</code>  是衡量多个查询的平均检索质量的</p><p><code>AP</code> 是衡量单个查询的检索质量的</p><p>AP 的计算公式： 相关文档的理想排名位置除以实际排名位置， 然后相加。 </p>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 日常总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github搜索</title>
      <link href="/2020/04/08/200408github%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/04/08/200408github%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 按照项目名&#x2F;仓库名搜索（大小写不敏感）</span><br><span class="line">in:name xxx </span><br><span class="line"># 按照README搜索（大小写不敏感）</span><br><span class="line">in:readme xxx</span><br><span class="line"># 按照description搜索（大小写不敏感）</span><br><span class="line">in:description xxx</span><br><span class="line"># stars数大于xxx</span><br><span class="line">stars:&gt;xxx</span><br><span class="line"># forks数大于xxx</span><br><span class="line">forks:&gt;xxx</span><br><span class="line"># 编程语言为xxx</span><br><span class="line">language:xxx</span><br><span class="line"># 最新更新时间晚于YYYY-MM-DD</span><br><span class="line">pushed:&gt;YYYY-MM-DD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> github学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 指令学习</title>
      <link href="/2020/04/07/git-%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/04/07/git-%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="常用的几条命令"><a href="#常用的几条命令" class="headerlink" title="常用的几条命令"></a>常用的几条命令</h4><p><code>git remote add origin {https://github.com/}</code> {就是仓库地址}</p><p>我们init之后， 要把本地和仓库对应起来。 这样才能知道本地对应什么仓库。 </p><ul><li><code>git init</code></li><li><code>git add 1.txt</code></li><li><code>git commit -m &quot;xxxxx&quot;</code></li><li><code>git push origin master</code>   master 当前分支。 </li></ul><a id="more"></a><p><code>git status</code> 查看本地文件的状态； </p><p><code>git add .</code> 代表当前文件夹下的文件都添加到缓冲区。 </p><p><code>git reset [opt] 版本号</code></p><p><code>--hard 回滚归档区，缓冲区，工作区</code></p><p><code>--soft 回滚归档区</code></p><p><code>--mixed 回滚归档区，缓冲区</code></p><p><code>git log</code></p><p><code>git reflog</code>   查看之前的操作。 </p><p><code>git revert 版本号</code>  抠掉一次操作。 </p><p><code>git branch -v</code> 查看当前有哪些分支，并处于哪个分支。 </p><p><code>git checkout -b b1</code>  创建了b1 这个分支，并处于b1这个分支。 </p><p>-b 是创建的意思，如果是切换分支， 那就不用写 -b。 </p><p>假设当前分支是 <code>master</code></p><p><code>git merge b1</code> 把b1这个分支合并到当前分支。 也就是 master这个分支。 </p><p><code>git pull</code> 拉取远程仓库最新的版本。</p>]]></content>
      
      
      <categories>
          
          <category> github学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字与静态</title>
      <link href="/2020/04/07/%E6%95%B0%E5%AD%97%E4%B8%8E%E9%9D%99%E6%80%81/"/>
      <url>/2020/04/07/%E6%95%B0%E5%AD%97%E4%B8%8E%E9%9D%99%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h4 id="常数变量的名称应该要都是大写字母"><a href="#常数变量的名称应该要都是大写字母" class="headerlink" title="常数变量的名称应该要都是大写字母"></a>常数变量的名称应该要都是大写字母</h4><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final 的变量代表不能改变它的值</li><li>final 的method 代表你不能覆盖掉该method</li><li>final 的类代表你不能继承该类。</li></ul><h3 id="日期表示"><a href="#日期表示" class="headerlink" title="日期表示"></a>日期表示</h3><p><code>import java.util.Date</code></p><ul><li><p>完整的日期与时间 <code>%tc</code></p><p><code>String.format(&quot;%tc&quot;, new Date())</code></p><p><code>Sun Nov 28 14:52:41 MST 2004</code></p></li><li><p>只有时间：<code>%tr</code></p><p><code>String.format(&quot;%tr&quot;, new Date())</code></p><p><code>03:01:47 PM</code></p><a id="more"></a></li><li><p>周，月，日： <code>%tA %tB %td</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date today = <span class="keyword">new</span> Date();</span><br><span class="line">String.format(<span class="string">"%tA, %tB, %td"</span>, today, today, today);</span><br></pre></td></tr></table></figure><p><code>Sunday, November 28</code></p><p>不用多写参数的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date today &#x3D; new Date();</span><br><span class="line">String.format(&quot;%tA, %&lt;tB, %&lt;td&quot;, today);</span><br><span class="line">&#x2F;&#x2F; &lt; 代表重复之前的参数。</span><br></pre></td></tr></table></figure></li></ul><h3 id="操作日期"><a href="#操作日期" class="headerlink" title="操作日期"></a>操作日期</h3><p>取得当前的日期，我们就可以用 Date， </p><p>那就用 <code>java.util.Calendar</code> 来操作日期。</p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态</title>
      <link href="/2020/04/07/java%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2020/04/07/java%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="四种存取是权限"><a href="#四种存取是权限" class="headerlink" title="四种存取是权限"></a>四种存取是权限</h3><ul><li>private</li><li>default</li><li>protected</li><li>public</li></ul><p>public 类型的成员会被继承。</p><p>private 类型的成员不会被继承。</p><p>子类要是想继承父类， 要用到 extends。 </p><a id="more"></a><h3 id="继承的意义："><a href="#继承的意义：" class="headerlink" title="继承的意义："></a>继承的意义：</h3><ul><li>避免了重复程序代码</li><li>定义出共同的协议</li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>代表只能被赋值一次。 </p><h3 id="Java的接口就好像是100-的纯抽象类。"><a href="#Java的接口就好像是100-的纯抽象类。" class="headerlink" title="Java的接口就好像是100%的纯抽象类。"></a>Java的接口就好像是100%的纯抽象类。</h3><h3 id="extend-只能有一个，-但是implement可以有好多个。"><a href="#extend-只能有一个，-但是implement可以有好多个。" class="headerlink" title="extend 只能有一个， 但是implement可以有好多个。"></a>extend 只能有一个， 但是implement可以有好多个。</h3><p>extend 代表继承， implement 代表接口。 </p>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo github （3）配置的坑点</title>
      <link href="/2020/04/05/hexo-github/"/>
      <url>/2020/04/05/hexo-github/</url>
      
        <content type="html"><![CDATA[<h3 id="一：-新建分类页面和标签页面的时候"><a href="#一：-新建分类页面和标签页面的时候" class="headerlink" title="一： 新建分类页面和标签页面的时候"></a>一： 新建分类页面和标签页面的时候</h3><p>可以的源代码是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然而我写成这样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>为什么我会写成这样呢， 因为在 typora中打开的时候， 最上面和最下面的 —- 被自动渲染了， 所以就没有看到，当我打开源码的时候才开到， emmm，每次部署上去都出错， 搞得我心态都崩了。 emmm</p><h3 id="二：-侧边栏的图标不能显示，或者显示之后网页就不能进去了；"><a href="#二：-侧边栏的图标不能显示，或者显示之后网页就不能进去了；" class="headerlink" title="二： 侧边栏的图标不能显示，或者显示之后网页就不能进去了；"></a>二： 侧边栏的图标不能显示，或者显示之后网页就不能进去了；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:  &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br></pre></td></tr></table></figure><p>我写成上面那样是不行的， 或者我把后面的图标去掉，网页可以进，但没有图标。 </p><p>如果图标写在下面，也不可以。</p><p>机缘巧合我写成了这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:  &#x2F;|| home</span><br><span class="line">  about: &#x2F;about&#x2F;|| user</span><br><span class="line">  tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">  categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">  archives: &#x2F;archives&#x2F;|| archive</span><br></pre></td></tr></table></figure><p>就是||前面没有空格， 他就可以了。 </p><h3 id="还要坑，-但是我忘了。emmm"><a href="#还要坑，-但是我忘了。emmm" class="headerlink" title="还要坑， 但是我忘了。emmm"></a>还要坑， 但是我忘了。emmm</h3>]]></content>
      
      
      <categories>
          
          <category> hexo+github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo github (2)</title>
      <link href="/2020/04/05/hexo-github-2/"/>
      <url>/2020/04/05/hexo-github-2/</url>
      
        <content type="html"><![CDATA[<h3 id="首先注册一个-github-账号。"><a href="#首先注册一个-github-账号。" class="headerlink" title="首先注册一个 github 账号。"></a>首先注册一个 <code>github</code> 账号。</h3><p>新建一个仓库， 命名为 <code>{name}.github.io</code></p><p>name 为你的github的用户名， 所以每个用户名只能用一次</p><p>然后打开 hexo 的根目录， 找到站点配置文件，</p><a id="more"></a><p>找到最后的地方：</p><p><img src="https://s1.ax1x.com/2020/04/05/GBwPsS.png" alt=""></p><p>修改之后保存； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>之后就可以在用github的网站访问了。</p>]]></content>
      
      
      <categories>
          
          <category> hexo+github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo github（1）</title>
      <link href="/2020/04/04/hexo-github%EF%BC%881%EF%BC%89/"/>
      <url>/2020/04/04/hexo-github%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Windos-10-系统"><a href="#Windos-10-系统" class="headerlink" title="Windos 10 系统"></a>Windos 10 系统</h3><h3 id="按照-Node-js"><a href="#按照-Node-js" class="headerlink" title="按照 Node.js"></a>按照 Node.js</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官方地址</a></p><p><img src="https://img-blog.csdnimg.cn/2020040416165886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpZHN1bW1lcg==,size_16,color_FFFFFF,t_70" alt="选择左边的就好"></p><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><a id="more"></a><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官方网站</a><br>根据自己的电脑系统<br>下载下来一路安装就好。 </p><ul><li>安装git之后， 就可以换用 git bash 了，  在文件夹里面鼠标右键，找到 git bash 就可以了。 </li><li>以下所有的命令都会在 git bash 中完成 。 </li></ul><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><p>新建一个文件夹，命名 blog， 就是自己的博客放在这个 blog 文件夹里面。</p><p>查看node 和 npm 有没有安装成功<br><img src="https://img-blog.csdnimg.cn/20200404162751449.png" alt="查看node 和 npm 有没有安装成功"><br>先来安装个cnpm提高速度，以后下载什么东西都用cnpm<br>输入命令：<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>安装之后安装 hexo<br><code>cnpm install -g hexo-cli</code><br> 验证是否安装成功：<br> <code>hexo -v</code></p><h3 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h3><p>查看当前目录的位置 <code>pwd</code><br><img src="https://img-blog.csdnimg.cn/20200404165300217.png" alt="这是我的文件路径"><br>然后最主要的命令来了， 初始话 hexo，<br> <code>hexo init</code></p><p> hexo 的一些命令：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> hexo clean #用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure></p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p> <code>hexo  s</code><br><img src="https://img-blog.csdnimg.cn/20200404170908973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpZHN1bW1lcg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示， 我们可以用 <code>localhost:4000</code> 来访问我们的博客， 这个只是本地的。只有运行 hexo s 才可以访问。 </p><p>本地博客就搭建完成了。 之后就可以部署到 github 中了。 </p>]]></content>
      
      
      <categories>
          
          <category> hexo+github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/04/hello-world/"/>
      <url>/2020/04/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
